#include "FastQFile.h"
#include "FastQStatus.h"
#include "BaseAsciiMap.h"
#include "SamFile.h"
#include "SamValidation.h"
#include <thread>
#include <string>


void process_file(String filename, String filename1, String filename2) ;

int main(int argc, char ** argv)
{
   // Check for the appropriate number of arguments.
   std::thread  t(process_file, argv[1], argv[2], argv[3]);
   std::thread  t1(process_file, argv[4], argv[5], argv[6]);
   //std::thread t1(process_file, argv[2]);
   //std::thread t2(process_file, argv[3]);
   //std::thread t2(process_file, argv[3]);
   // Open the fastqfile with the default UNKNOWN space type which will determine the 
   // base type from the first character in the sequence.
   t.join();
   t1.join();
   //t2.join();
   //t2.join();
   return 0;
}

void process_file(String filename1, String filename2, String filename3) {
   FastQFile fastQFile1(4, 4);
   FastQFile fastQFile2(4, 4);
   FastQFile fastQFile3(4, 4);

   if(fastQFile1.openFile(filename1, BaseAsciiMap::UNKNOWN) != FastQStatus::FASTQ_SUCCESS)
   {
      std::cerr << "Failed to open file: " <<  filename1.c_str();
      return;
   }

/*
   if(fastQFile2.openFile(filename2, BaseAsciiMap::UNKNOWN) != FastQStatus::FASTQ_SUCCESS)
   {
      std::cerr << "Failed to open file: " <<  filename2.c_str();
      return;
   }

   if(fastQFile3.openFile(filename3, BaseAsciiMap::UNKNOWN) != FastQStatus::FASTQ_SUCCESS)
   {
      std::cerr << "Failed to open file: " <<  filename3.c_str();
      return;
   }
*/
   SamFile samOut;
   samOut.OpenForWrite(filename1 + String(".bam"));
   // Keep reading the file until there are no more fastq sequences to process.
   SamRecord samRecord;
   int i = 0;
   while (fastQFile1.keepReadingFile())
   {
      // Read one sequence. This call will read all the lines for 
      // one sequence.
      /////////////////////////////////////////////////////////////////
      // NOTE: It is up to you if you want to process only for success:
      //    if(readFastQSequence() == FASTQ_SUCCESS)
      // or for FASTQ_SUCCESS and FASTQ_INVALID: 
      //    if(readFastQSequence() != FASTQ_FAILURE)
      // Do NOT try to process on a FASTQ_FAILURE
      /////////////////////////////////////////////////////////////////
      if(fastQFile1.readFastQSequence() == FastQStatus::FASTQ_SUCCESS )
      {
         // The sequence is valid.
         // For example if you want to print the lines of the sequence:
        // printf("%s\n", fastQFile.mySequenceIdentifier.c_str());
/*
         printf("%s\n", fastQFile.mySequenceIdLine.c_str());
         printf("%s\n", fastQFile.myRawSequence.c_str());
         printf("%s\n", fastQFile.myPlusLine.c_str());
         printf("%s\n", fastQFile.myQualityString.c_str());
*/
         i = i + 1;
         if(i % 1000000 == 0) {  
             printf("%d\n", i);
             std::string a = std::string(fastQFile1.myRawSequence.c_str());
             printf("%s\n", a.substr(0,6).c_str());
             printf("%s\n", fastQFile1.mySequenceIdLine.c_str());
             printf("%s\n", fastQFile1.myRawSequence.c_str());
         }
      }
   }
   // Finished processing all of the sequences in the file.
   // Close the input file.
   fastQFile1.closeFile();
}


 F1_R1.fastq  F1_R2.fastq F1_I1.fastq    T1    B1, B2, B2, B2, B1,   ...
     q1  BAM1 ...
     q2  ......
     q3 
     q4
     q5
     q6
     set_and_test



 F2_R1.fastq  F1_R2.fastq F1_I1.fastq    T2    B4, B4, B1, B1

     q3 

 F3_R1.fastq  F1_R2.fastq F1_I1.fastq    T3



 F3_R1.fastq  F1_R2.fastq F1_I1.fastq    T4


 F5_R1.fastq  F1_R2.fastq F1_I1.fastq    T5





BAM1    B1, B4
BAM2    B3, B3, B3
BAM3
BAM4
BAM5
BAM6






/*
#include "SamFile.h"
#include "SamValidation.h"

int sam(int argc, char ** argv)
{
   // Open the input file for reading.
   SamFile samIn;
   samIn.OpenForRead(argv[1]);

   // Open the output file for writing.
   SamFile samOut;
   samOut.OpenForWrite(argv[2]);

   // Read the sam header.
   SamFileHeader samHeader;
   samIn.ReadHeader(samHeader);

   // Write the sam header.
   samOut.WriteHeader(samHeader);

   SamRecord samRecord;

    // Set returnStatus to success.  It will be changed
    // to the failure reason if any of the writes fail.
    SamStatus::Status returnStatus = SamStatus::SUCCESS;

    // Keep reading records until ReadRecord returns false.
    while(samIn.ReadRecord(samHeader, samRecord))
    {
        // Successfully read a record from the file, so write it.
        samOut.WriteRecord(samHeader, samRecord);
    }

    std::cout << std::endl << "Number of records read = " << 
        samIn.GetCurrentRecordCount() << std::endl;
    std::cout << "Number of records written = " << 
        samOut.GetCurrentRecordCount() << std::endl;

    // Return success since a failure would have thrown
    // an exception.
    return(returnStatus);
 }
*/
